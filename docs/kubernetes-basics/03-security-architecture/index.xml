<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security Architecture on Kubernetes Security Training</title><link>/docs/kubernetes-basics/03-security-architecture/</link><description>Recent content in Security Architecture on Kubernetes Security Training</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/docs/kubernetes-basics/03-security-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>RBAC</title><link>/docs/kubernetes-basics/03-security-architecture/03/_rbac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_rbac/</guid><description>Role Based Access Control Until now we just assumed that we have the necessary right to do our tasks in kubernetes. But how are users Authenticated and Authorized in Kubernetes/the Kubernetes API?
Users in Kubernetes All Kubernetes clusters have two categories of users: service accounts managed by Kubernetes, and normal users.
It is assumed that a cluster-independent service manages normal users in the following ways:
an administrator distributing private keys a user store like Keystore or Google Accounts a file with a list of usernames and passwords In this regard, Kubernetes does not have objects which represent normal user accounts.</description></item><item><title>Architecture and encryption</title><link>/docs/kubernetes-basics/03-security-architecture/03/_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_architecture/</guid><description>In order to secure Kubernetes we want to understand its different components. For that, we install a minimal Kubernetes Distribution ourselves:
Task 3.2.1: Install a Kubernetes Cluster For this task we need to switch to a VM, there we will install a Kubernetes Cluster using kind SSH into your VM: You find the relevant command in the file welcome
ssh -i /home/project/id-ecdsa &amp;lt;namespace&amp;gt;@159.69.155.196 Now download kind:
curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.24.0/kind-linux-amd64 chmod +x .</description></item><item><title>PSA</title><link>/docs/kubernetes-basics/03-security-architecture/03/_psa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_psa/</guid><description>Pod Security Admission (PSA) Kubernetes Pod Security Admission (PSA) is a mechanism designed to enforce security policies on pods based on predefined security profiles (so-called Pod Security Standards (PSS)). It provides a way to ensure that pods meet certain security standards before they are allowed to run in a Kubernetes cluster.
PSA works by evaluating pod security based on three profiles :
Privileged: Offers the highest level of privileges, with minimal restrictions.</description></item><item><title>Custom Policies</title><link>/docs/kubernetes-basics/03-security-architecture/03/_custom-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_custom-policies/</guid><description>Until now we learned best practices on how to secure our workload in Kubernetes, but as a cluster admin. How can we enforce certain regulations for resources in our cluster? Sometimes we need to be more specific than the 3 PSP this is where policy engines like Open Policy Agent (OPA) or Kyverno come into play.
Kyverno Kyverno is an open-source policy engine designed specifically for Kubernetes. It allows you to manage and enforce security and compliance policies for your Kubernetes resources using custom resource definitions (CRDs).</description></item><item><title>Runtime Security</title><link>/docs/kubernetes-basics/03-security-architecture/03/_runtime-sec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_runtime-sec/</guid><description>Kubernetes clusters are dynamic, with workloads constantly being scheduled, modified, and removed. While static security measures (e.g., image scanning, Pod Security Policies) focus on vulnerabilities before deployment, runtime security tools like Falco detect threats as they occur.
This includes:
Detecting anomalous behavior (e.g., unexpected process executions in containers). Identifying suspicious network activity (e.g., unexpected connections or port scans). Tracking system calls for unauthorized actions (e.g., privilege escalation attempts). Falco is an open-source Kubernetes threat detection engine.</description></item><item><title/><link>/docs/kubernetes-basics/03-security-architecture/03/rbac-solution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/rbac-solution/</guid><description>Students will get a Timeout error because there is still an Network Policy blocking their requests. They will have to delete that policy.</description></item><item><title/><link>/docs/kubernetes-basics/03-security-architecture/mount-secrets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/mount-secrets/</guid><description>Create a secret:
kubectl create secret generic my-secret --from-literal=username=myuser --from-literal=password=mypassword Run a pod with the secret mounted:
kubectl exec -it kubectl-pod -- sh inside this pod
kubectl run secret-mount-pod --image=alpine --overrides=&amp;#39; { &amp;#34;apiVersion&amp;#34;: &amp;#34;v1&amp;#34;, &amp;#34;spec&amp;#34;: { &amp;#34;volumes&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;secret-volume&amp;#34;, &amp;#34;secret&amp;#34;: { &amp;#34;secretName&amp;#34;: &amp;#34;my-secret&amp;#34; } } ], &amp;#34;containers&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;alpine&amp;#34;, &amp;#34;command&amp;#34;: [&amp;#34;cat&amp;#34;, &amp;#34;/etc/secret-volume/username&amp;#34;, &amp;#34;/etc/secret-volume/password&amp;#34;], &amp;#34;image&amp;#34;: &amp;#34;alpine&amp;#34;, &amp;#34;volumeMounts&amp;#34;: [ { &amp;#34;mountPath&amp;#34;: &amp;#34;/etc/secret-volume&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;secret-volume&amp;#34;, &amp;#34;readOnly&amp;#34;: true } ] } ] } }&amp;#39; These commands create a secret and then run a pod that mounts the secret at /etc/secret-volume.</description></item></channel></rss>