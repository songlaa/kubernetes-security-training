<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes Security Training</title><link>/</link><description>Recent content on Kubernetes Security Training</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>/docs/kubernetes-basics/01-basics/01/_introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/01-basics/01/_introduction/</guid><description>All explanations and resources used in this lab give only a quick and not detailed overview. Please check the official documentation to get further details.
Core concepts With the open source software Kubernetes, you get a platform to deploy your application in a container and operate it at the same time. Therefore, Kubernetes is also called a Container Platform, or the term Container-as-a-Service (CaaS) is used.
Depending on the configuration the term Platform-as-a-Service (PaaS) works as well.</description></item><item><title>RBAC</title><link>/docs/kubernetes-basics/03-security-architecture/03/_rbac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_rbac/</guid><description>Role Based Access Control Until now we just assumed that we have the necessary right to do our tasks in kubernetes. But how are users Authenticated and Authorized in Kubernetes/the Kubernetes API?
Users in Kubernetes All Kubernetes clusters have two categories of users: service accounts managed by Kubernetes, and normal users.
It is assumed that a cluster-independent service manages normal users in the following ways:
an administrator distributing private keys a user store like Keystore or Google Accounts a file with a list of usernames and passwords In this regard, Kubernetes does not have objects which represent normal user accounts.</description></item><item><title>Securing the frontend</title><link>/docs/kubernetes-basics/02-secure-workload/02/_sec-frontend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/02-secure-workload/02/_sec-frontend/</guid><description>Right now we have a fully functioning application, but we want to run it as securely as possible. In Docker, we would make sure to run as an unprivileged user, drop unnecessary capabilities and use a Mandatory Access Control System like AppArmor. Let us apply that to Kubernetes!
In Kubernetes, the SecurityContext defines security-related settings for both Pods and individual Containers. It allows you to control various security aspects of your workloads, such as user permissions, capabilities, and Linux security features (like SELinux, AppArmor, and seccomp).</description></item><item><title>Architecture and encryption</title><link>/docs/kubernetes-basics/03-security-architecture/03/_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_architecture/</guid><description>In order to secure Kubernetes we want to understand its different components. For that, we install a minimal Kubernetes Distribution ourselves:
Task 3.2.1: Install a Kubernetes Cluster For this task we need to switch to a VM, there we will install a Kubernetes Cluster using kind SSH into your VM: You find the relevant command in the file welcome
ssh -i /home/project/id-ecdsa &amp;lt;namespace&amp;gt;@159.69.155.196 Now download kind:
curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.24.0/kind-linux-amd64 chmod +x .</description></item><item><title>Deployments</title><link>/docs/kubernetes-basics/01-basics/01/_deployments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/01-basics/01/_deployments/</guid><description>We are finally ready to get started with Kubernetes. You should have been given the setup instructions by your teacher and be logged in your namespace.
In this lab, we deploy our first container image and look at the concepts of Pods, Services, and Deployments.
Task 1.2.1: Start and stop a single Pod We have a look at deploying a pre-built container image from Quay.io or any other public container registry.</description></item><item><title>Network Policies</title><link>/docs/kubernetes-basics/02-secure-workload/02/_network-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/02-secure-workload/02/_network-policies/</guid><description>Kubernetes Networking Kubernetes networking is designed to allow communication between various components like pods, services, and external resources. It ensures that containers can interact with each other.
Container Network Interface (CNI) is a specification for network plugins in Kubernetes. It enables the network layer to be abstracted and customized based on the specific requirements of the cluster. CNIs are responsible for configuring networking when a pod is started or terminated. CNI plugins allow Kubernetes clusters to use different networking models or overlay networks, making it possible to scale across diverse environments.</description></item><item><title>Exposing a Service</title><link>/docs/kubernetes-basics/01-basics/01/_service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/01-basics/01/_service/</guid><description>In this lab, we are going to make the frontend from the last lab accessible externally.
Task 1.3.1: Create a ClusterIP Service The command kubectl apply -f deployment_example-frontend.yaml from the last lab creates a Deployment but no Service.
A Kubernetes Service is an abstract way to expose an application running on a set of Pods as a network service. For some parts of your application (like frontends), you may want to expose a Service to an external IP address outside your cluster.</description></item><item><title>PSA</title><link>/docs/kubernetes-basics/03-security-architecture/03/_psa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_psa/</guid><description>Pod Security Admission (PSA) Kubernetes Pod Security Admission (PSA) is a mechanism designed to enforce security policies on pods based on predefined security profiles (so-called Pod Security Standards (PSS)). It provides a way to ensure that pods meet certain security standards before they are allowed to run in a Kubernetes cluster.
PSA works by evaluating pod security based on three profiles :
Privileged: Offers the highest level of privileges, with minimal restrictions.</description></item><item><title>Backend</title><link>/docs/kubernetes-basics/01-basics/01/_database/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/01-basics/01/_database/</guid><description>Numerous applications are stateful in some way and want to save data persistently, whether in a database, as files on a filesystem, or in an object store. In this lab, we will create a MariaDB database and configure our application to store its data in it.
Task 1.4.1: Instantiate a MariaDB database We will first create a so-called Secret in which we store sensitive data. The secret will be used to access the database and also to create the initial database.</description></item><item><title>Custom Policies</title><link>/docs/kubernetes-basics/03-security-architecture/03/_custom-policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_custom-policies/</guid><description>Until now we learned best practices on how to secure our workload in Kubernetes, but as a cluster admin. How can we enforce certain regulations for resources in our cluster? Sometimes we need to be more specific than the 3 PSP this is where policy engines like Open Policy Agent (OPA) or Kyverno come into play.
Kyverno Kyverno is an open-source policy engine designed specifically for Kubernetes. It allows you to manage and enforce security and compliance policies for your Kubernetes resources using custom resource definitions (CRDs).</description></item><item><title>Scenario 1</title><link>/docs/kubernetes-basics/04-ctf/04/_scen1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/04-ctf/04/_scen1/</guid><description>First setup the Scenario:
# don&amp;#39;t spoil and look at the files... curl -LO https://kubernetes-security.songlaa.com/ctf/1/1setup.sh chmod +x 1setup.sh ./1setup.sh You were given rights to execute containers on a CI/CD Pipeline. Of course you tried to create a reverse-shell and suceeded. Now on to more!
Task 4.1.1: Find verifications that you are in a pod There are some giveaways that you are inside a Kubernetes Pod. Find 3 of them. After you did that manually you can also google if there are tools available for that.</description></item><item><title>Scenario 2</title><link>/docs/kubernetes-basics/04-ctf/04/_scen2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/04-ctf/04/_scen2/</guid><description>First setup the Scenario:
# don&amp;#39;t spoil and look at the files... curl -LO https://kubernetes-security.songlaa.com/ctf/2/2setup.sh chmod +x 2setup.sh ./2setup.sh # you might need to wait 1 minute if access to ssh fails This is a tough CTF: you were overhearing a conversation and heard the password &amp;ldquo;songlaa&amp;rdquo;. When you did some osint you found the IP of server. Now you have access to a Kubernetes Cluster! Try to become cluster admin!</description></item><item><title>Runtime Security</title><link>/docs/kubernetes-basics/03-security-architecture/03/_runtime-sec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/kubernetes-basics/03-security-architecture/03/_runtime-sec/</guid><description>Kubernetes clusters are dynamic, with workloads constantly being scheduled, modified, and removed. While static security measures (e.g., image scanning, Pod Security Policies) focus on vulnerabilities before deployment, runtime security tools like Falco detect threats as they occur.
This includes:
Detecting anomalous behavior (e.g., unexpected process executions in containers). Identifying suspicious network activity (e.g., unexpected connections or port scans). Tracking system calls for unauthorized actions (e.g., privilege escalation attempts). Falco is an open-source Kubernetes threat detection engine.</description></item><item><title>Windows</title><link>/setup/local-usage/cli-installation/windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/setup/local-usage/cli-installation/windows/</guid><description>Installation for Windows Follow the steps outlined in https://kubernetes.io/docs/tasks/tools/install-kubectl/ .
In case the installation from the official package repositories didn&amp;rsquo;t work (or a specific version is needed) the static binary can be downloaded and put into the following path:
C:\Kubernetes\ In Windows, the PATH can be set in the advanced system settings. It depends on the version:
Windows 10 Windows 11 Note: Windows Quick Hack Copy the kubectl binary directly into the folder C:\Windows.</description></item><item><title>macOS</title><link>/setup/local-usage/cli-installation/macos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/setup/local-usage/cli-installation/macos/</guid><description>Installation for macOS Follow the steps outlined in https://kubernetes.io/docs/tasks/tools/install-kubectl/ .
In case the installation from the official package repositories didn&amp;rsquo;t work (or a specific version is needed) the static binary can be downloaded and put into the following path:
~/bin File mode The kubectl binary has to be executable:
cd ~/bin chmod +x kubectl PATH variable In macOS, the directory ~/bin should already be part of the PATH variable. In case kubectl is placed in a different directory, you can change the PATH variable with the following command:</description></item><item><title>Linux</title><link>/setup/local-usage/cli-installation/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/setup/local-usage/cli-installation/linux/</guid><description>Installation for Linux Follow the steps outlined in https://kubernetes.io/docs/tasks/tools/install-kubectl/ .
In case the installation from the official package repositories didn&amp;rsquo;t work (or a specific version is needed) the static binary can be downloaded and put into the following path:
~/bin File mode The kubectl binary has to be executable:
cd ~/bin chmod +x kubectl PATH variable In Linux, the directory ~/bin should already be part of the PATH variable. In case kubectl is placed in a different directory, you can change the PATH variable with the following command:</description></item></channel></rss>